//----------------------------------------------------
//
// Generated by www.easywsdl.com
// Version: 5.7.0.0
//
// Created by Quasar Development 
//
//---------------------------------------------------


import Foundation


class EPA_FdV_AUTHN_Helper
{
    static let MS_SERIALIZATION_NS:String = "http://schemas.microsoft.com/2003/10/Serialization/"
    static let XSI:String = "http://www.w3.org/2001/XMLSchema-instance"
    static let dotLocale:[String:String]=[
        NSLocale.Key.decimalSeparator.rawValue:"."
    ]

    class func createGuid() -> String
    {
        return NSUUID().uuidString
    }
    class func isValue (node:DDXMLElement?, name:String) -> Bool
    {
        if node == nil
        {
            return false
        }
        if node!.localName == name
        {
            let nilAttr:DDXMLNode?=getAttribute(node: node ,name:"nil", url:EPA_FdV_AUTHN_Helper.XSI)
            return nilAttr === nil
        }
        return true
    }

    class func getAttribute (node:DDXMLElement?, name:String, url:String) -> DDXMLNode?
    {
        if node == nil
        {
            return nil
        }
        var fullName:String=name
        let prefix = node!.resolvePrefix(forNamespaceURI:url)
        if prefix != nil && !prefix!.isEmpty
        {
            fullName=prefix!.appendingFormat(":%@",name)
        }
        let typeAttr:DDXMLNode?=node!.attribute(forName:fullName)
        return typeAttr
    }

    class func getAttribute(node:DDXMLElement?, name:String ) -> DDXMLNode?
    {
        return node?.attribute(forName:name)
    }

    class func getResultElement(body:DDXMLElement, name:String) ->DDXMLElement
    {
        let resultElement=body.child(at:0) as! DDXMLElement
        if resultElement.childCount>0
        {
            let propertyElement=resultElement.child(at:0)

            if propertyElement?.localName==name
            {
                return propertyElement as! DDXMLElement
            }
        }
        if resultElement.localName == name
        {
            return resultElement
        }
        return body
    }

    class func base64forData(data:Data) ->String
    {
        let base64Data = data.base64EncodedString(options:NSData.Base64EncodingOptions(rawValue: 0))
        return String(base64Data)
    }

    class func base64DataFromString(string:String) ->Data
    {
        let decodedData = Data(base64Encoded: string,options: NSData.Base64DecodingOptions(rawValue: 0))
        return decodedData!
    }
    class func getNode(node:DDXMLElement?, name:(String), URI:String) ->DDXMLElement?
    {
        if node == nil
        {
            return nil
        }
        let items = node!.elements(forLocalName:name ,uri:URI)
        if items.count>0
        {
            return items[0]
        }
        return nil
    }


    class func hasAttribute(node:DDXMLElement?, name:String,url:String) ->Bool
    {
        let child=getAttribute(node: node ,name: name,url:url)
        return child != nil
    }

    class func getNode(node:DDXMLElement?, name:String) -> DDXMLElement?
    {
        return getNode(node: node ,name:name ,index:0)
    }

    class func getNode(node:DDXMLElement?, name:String, index:Int) -> DDXMLElement?
    {
        if node == nil
        {
            return nil
        }
        let items = node!.elements(forName: name)
        if items.count>index
        {
            let element = items[index]
            return element
        }
        return nil
    }

    class func hasAttribute(node:DDXMLElement?, name:String) ->Bool
    {
        let child=getAttribute(node: node ,name: name)
        return child != nil
    }

    class func hasValue(node:DDXMLElement?, name:String) ->Bool
    {
        return hasValue(node: node, name:name, index:0)
    }

    class func hasValue(node:DDXMLElement?, name:String,index:Int) ->Bool
    {
        let child=getNode(node: node, name: name,index: index)
        if child != nil
        {
            let nilAttr=getAttribute(node: child!, name: "nil", url:XSI)
            return nilAttr==nil
        }
        return false
    }


    class func toBoolStringFromNumber(boolNumber:NSNumber?) ->String?
    {
        if boolNumber != nil
        {
            return boolNumber!.boolValue ? "true" : "false"
        }
        return nil
    }

    class func toBoolStringFromBool(boolValue:Bool)  ->String
    {
        return boolValue ? "true" : "false"
    }

    class func getStringFromNumber(number:NSNumber)  ->String
    {
        return number.description(withLocale:dotLocale)
    }
    
    class func toBoolFromString(str:String) ->Bool
    {
        switch str{
            case "True","true","yes","1":
                return true
            case "False","false","no","0":
                return false
        default:
            return false
        }
    }

    class func getNumber(stringNumber:String?, isDecimal:Bool)  -> NSNumber?
    {
        if stringNumber == nil
        {
            return nil
        }
        let formatter = NumberFormatter()
        formatter.decimalSeparator="."
        if isDecimal
        {
            formatter.numberStyle=NumberFormatter.Style.decimal
            return Decimal(string:stringNumber!,locale:formatter.locale) as NSNumber?
        }
        return formatter.number(from: stringNumber!)
    }

    class func getDate(stringDate:String?) ->Date?
    {
        if stringDate != nil && !stringDate!.isEmpty
        {
            let formats : [String]=["yyyy-MM-dd'T'HH:mm:ss.SSSZ",
                                    "yyyy-MM-dd'T'HH:mm:ss.SSS",
                                    "yyyy-MM-dd'T'HH:mm:ssZZZZ",
                                    "yyyy-MM-dd'T'HH:mm:ssZ",
                                    "yyyy-MM-dd'T'HH:mm:ss",
                                    "yyyy-MM-dd'T'HH:mmZ",
                                    "yyyy-MM-dd'T'HH:mm",
                                    "yyyy-MM-ddZZZZ",
                                    "yyyy-MM-ddZ",
                                    "yyyy-MM-dd"];
            let dateFormatter = DateFormatter()
            dateFormatter.locale=Locale(identifier: "en_US_POSIX")
            dateFormatter.timeZone=TimeZone(abbreviation: "UTC")

            for format in formats
            {
                dateFormatter.dateFormat=format
                let date = dateFormatter.date(from:stringDate!)
                if date != nil
                {
                    return date
                }
            }
        }
        return nil
    }

    class func getStringFromDate(date:Date?) -> String?
    {
        if date != nil
        {
            let dateFormatter = DateFormatter()
            dateFormatter.dateFormat="yyyy-MM-dd"
            dateFormatter.timeZone = TimeZone(abbreviation: "UTC")
            return dateFormatter.string(from: date!)
        }
        return nil
    }

    class func getStringFromDateTime(date:Date?) -> String?
    {
        if date != nil
        {
            let dateFormatter = DateFormatter()
            dateFormatter.dateFormat="yyyy-MM-dd'T'HH:mm:ss"
            dateFormatter.timeZone = TimeZone(abbreviation: "UTC")
            return dateFormatter.string(from: date!)
        }
        return nil
    }
    class func removeObject(object : DDXMLElement,array: inout [DDXMLElement])
    {
        if let index = array.firstIndex(of: object) {
            array.remove(at: index)
        }
    }}
